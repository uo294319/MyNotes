# Coordination and consensus
---
[Go Back](../README.md)

---
## Introduction
- Why is it difficult to coordinate distributed systems?
	- Similar to multi-thread applications but without shared resources (semaphores or locks).
	- They coordinate through the network.
	- Nodes can fail separately. Impossible to differentiate from network delay.
- Coordination cases:
	- **Mutual exclusion** in access to resources.
	- **Election algorithms**. Nodes vote to choose a temporal leader or broker.
	- **Multicast** in groups of processes (only with point-to-point, not in UDP)
	- **Consensus**. System-wide decisions. Not only data but sequence of operations.
---
## Mutual Exclusion
### Definition
- A resource cannot be accessed by several processes at the same time.
- We define a critical section that can only be executed by one process.
### Non-Distributed Systems
- **Mutexes (locks)**.
	- When a process "grabs" it, no other process can do so until the first "drops it".
- **Semaphores** (generalisation of locks)
	- Store a counter that cannot go below 0.
	- Processes can decrement it with `sem_wait()` or increase it with `sem_post()`.
	- If a process tries to decrement it when it is 0, it is locked until other one increments it.
- **Monitors**
	- Data structure in object-oriented programming (java) to mark code as synchronised.
	- Internally works with a lock.
### Distributed Systems
- Types:
	- **Centralized**
		- Some process is designated as the referee
		- Other process ask him for permission through network messages.
	- **Decentralized**
		- There is no referee.
		- Processes agree among themselves which can enter their critical section.
- Algorithm properties
	1. **Mutual exclusion**. Only one process can enter the critical section at a time.
	2. **Survivability (or liveness)** . No process should "starve" (never receive permission)
	3. **Ordering (optional)**. Permissions are granted in the same order they are requested.
### Centralized Referee Solution
- **A referee is designated**
	- We imagine a "token" which the process executing the critical section must have.
	- The referee manages the "token" and it is in charge of granting it.
	- It has a boolean indicating if the token is available and a queue for pending requests.
- **Steps**
	1. A process `P1` request the "token" to the referee.
	2. The referee grants the "token" to `P1` so it enters the critical section.
	3. Another process `P2` requests for the "token".
	4. As the referee has no token, `P2` blocks and it is added to the referee's queue.
	5. The process `P1` ends its critical section and frees the "token".
	6. The referee grants the "token" to the next process in the queue `P2`.
- **Other implementations**
	- Referee can have several tokens for different critical sections.
	- Referee can have a thread per client and implement actual locks.
- **Advantages**
	- Grants mutual exclusion and survivability.
	- Only grants ordering if the queue is a FIFO queue.
- **Problems** (Fault-Tolerance)
	- The referee is a single point of failure.
	- If a token is lost (network or process failure) there is an infinite lockout.
### Token Ring Solution (Descentralized)
- **Ring concept**
	- Administrator configures each node with a unique identifier.
	- Nodes are ordered in a ring where each know the next and previous node's IP.
	- A token is in continuous circulation through the ring from one node to the next.
- **When a process want to access a critical section**
	1. Waits until it receives the token.
	2. It holds the token while executing the critical section.
	3. It retransmits the token when it ends.
- **Advantages**
	- Grants mutual exclusion and survivability.
	- Does not grant ordering. The order is determined by the identifier, not the request time.
- **Problems**
	- Consumes bandwidth continuously. If no critical section, token circulates at high speed.
	- If a message is lost, the token "disappears". Difficult to regenerate based on timeouts.
	- Token stops circulating if a node dies. Ring reconfiguration will imply knowing more nodes.
- **Other descentralized solutions**
	- P2P algorithms based on Distributed Hash Table (DHT)
	- Voting algorithms
---
## Consensus
### Definition
- **Distributed system nodes must make decisions as a whole.**
	- One node makes the decision and remaining nodes must be aware.
	- This ensures consistency across nodes.
- **Node Problems**
	- Nodes may stop working because of `segfault`or hardware errors.
	- Nodes that has been down for a while, loss some information.
	- A node can send wrong or contradictory messages. (byzantine failure)
		- Because of software bug, hardware failure or malicious nodes.
- **Network Problems**
	- Corrupt or out of order data (TCP solves this)
	- Network partitioning (disconnected sub-networks)
		- Some nodes become unreachable.
		- Difficult to differentiate from node down.
### System models
- **Failure Model**
	- **Crash only**
		- The only way a process can fail is a _crash_. Node works fine until it stops working.
		- Possible to build failure detectors (imposible to distingues from network failure)
	- **Byzantine failures**
		- Process fails but still continue sending messages.
		- Messages are not reliable and can lead the algorithm to incorrect decisions.
	- **Malicious**
		- Process sends messages "intelligently" designed to confuse the consensus algorithm.
		- Impossible to differentiate a virus controlled by an attacker from a byzantine bug.
- **Network Model**
	- Corrupt or out of order data. Not considered as TCP solves this.
	- Network partitioning.
		- Router fails, resulting in several disconnected sub-networks.
		- Some networks become unreachable.
	- Types of networks
		- Synchronous networks
			- Guarantees a finite delivery time by design.
			- If no response arrives in that time, it will never arrive.
			- Usually with global clocks transmitted through the network.
		- Asynchronous networks
			- The clocks are not perfectly synchronized.
			- Delivery time is not bounded. Can be infinite in the worst cases.
			- Internet is asynchronous.
			- With TCP impossible to differentiate lost messages from network delays.
- **Consistency Model**
	- Strong consistency
		- Guarantees that there is consistency before any response to the requesting client.
	- Eventual consistency
		- Guarantees that there will be consistency, but not necessarily before the response.
### Impossibility results
- Ideal but imposible situation.
	- Asynchronous network (Internet with TCP/IP).
	- Arbitrary failures (Byzantine, nodes with errors keep sending erroneous messages)
	- Strong consistency
- Fischer, Lynch and Paterson (FLP) Result
	- Model: Asynchronous network, crash only and eventual consistency
	- Demonstrates that there is no algorithm that guarantees consensus.
	- How?
		- It is impossible to differentiate downed node from network delays.
		- Retries must be made but messages considered lost can arrive later.
		- This result in an infinite cycle.
	- Not usually considered a problem. There are algorithms that work 99.9% of the time.
- **CAP theorem**
	- Demonstrates that it is impossible to achieve the three objectives:
		- Strong Consistency (All clients always see the same data)
		- Availability (All clientes can access the data even if a node fail)
		- Partitioning (continue working with network partitions)
	- How?
		- A client performs a write and there is a network partition
		- If the operation is allowed, availability is preserved but not the consistency.
		- If an error is presented to the user, consistency is preserved but not availability.
	- Choosing
		- Partitions will happen so availability (AP) or strong consistency (CP) should be chosen.
		- Modern distributed DB (No-SQL) choose availability having an eventual consistency.
- Case studies and known solutions (for asynchronous networks)
	- Paxos or RAFT
		- Solves crash failures with partitions achieving eventual consistency
	- Byzantine Generals
		- Solves byzantine failures with partitions.
		- Consensus may be achieved depending on the number of node failures.
	- Blockchain
		- Solves byzantine or malicious failures with partitions by using cryptography.
		- When a consensus problem happens, all nodes must agree.
		- Economic benefits to nodes that behave well.
		- Great energy cost to prevent cheap cheating.
### Byzantine failures
- Two Generals problem
	- Definition:
		- We have two generals with their armies that are separated.
		- They all must decide whether to attack or not (consensus).
		- They communicate through a messenger that might be captured.
	- Problem
		- Infinite loop to confirm message reception.
		- If messages can be lost, the problem has no solution.
- Byzantine Generals
	- We assume that messages will arrive sooner or latter (TCP protocol)
		- 
---