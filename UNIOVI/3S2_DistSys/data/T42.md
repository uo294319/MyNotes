# Coordination and consensus
---
[Go Back](../README.md)

---
## Introduction
- Why is it difficult to coordinate distributed systems?
	- Similar to multi-thread applications but without shared resources (semaphores or locks).
	- They coordinate through the network.
	- Nodes can fail separately. Impossible to differentiate from network delay.
- Coordination cases:
	- **Mutual exclusion** in access to resources.
	- **Election algorithms**. Nodes vote to choose a temporal leader or broker.
	- **Multicast** in groups of processes (only with point-to-point, not in UDP)
	- **Consensus**. System-wide decisions. Not only data but sequence of operations.
---
## Mutual Exclusion
### Definition
- A resource cannot be accessed by several processes at the same time.
- We define a critical section that can only be executed by one process.
### Non-Distributed Systems
- **Mutexes (locks)**.
	- When a process "grabs" it, no other process can do so until the first "drops it".
- **Semaphores** (generalisation of locks)
	- Store a counter that cannot go below 0.
	- Processes can decrement it with `sem_wait()` or increase it with `sem_post()`.
	- If a process tries to decrement it when it is 0, it is locked until other one increments it.
- **Monitors**
	- Data structure in object-oriented programming (java) to mark code as synchronised.
	- Internally works with a lock.
### Distributed Systems
- Types:
	- **Centralized**
		- Some process is designated as the referee
		- Other process ask him for permission through network messages.
	- **Decentralized**
		- There is no referee.
		- Processes agree among themselves which can enter their critical section.
- Algorithm properties
	- **Mutual exclusion**. Only one process can enter the critical section at a time.
	- **Survivability (or liveness)** . No process should "starve" (never receive permission)
	- **Ordering (optional)**. Permissions are granted in the same order they are requested.
### Centralized Referee Solution
- A referee is designated
	- We imagine a "token" which only the process executing the critical section can have.
	- The referee manages the "token" and it is in charge of granting it.
	- It has a boolean indicating if the token is available and a queue for pending requests.
- Steps:
	1. A process `P1` request the "token" to the referee.
	2. The referee grants the "token" to `P1` so it enters the critical section.
	3. Another process `P2` requests for the "token".
	4. As the referee has no token, `P2` blocks and it is added to the referee's queue.
	5. The process `P1` ends its critical section and frees the "token".
	6. The referee grants the "token" to the next process in the queue `P2`.
- Other implementations:
	- Referee can have several tokens for different critical sections.
	- Referee can have a thread per client and implement actual locks.
- Fault-Tolerance problems.
	- The referee is a single point of failure.
	- If network fails when the token is granted, it disappears.
	- If the process with the token fails, all pending processes remain blocked.
---
## Consensus

---