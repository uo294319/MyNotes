# Coordination and consensus
---
[Go Back](../README.md)

---
## Introduction
- Why is it difficult to coordinate distributed systems?
	- Similar to multi-thread applications but without shared resources (semaphores or locks).
	- They coordinate through the network.
	- Nodes can fail separately. Impossible to differentiate from network delay.
- Coordination cases:
	- **Mutual exclusion** in access to resources.
	- **Election algorithms**. Nodes vote to choose a temporal leader or broker.
	- **Multicast** in groups of processes (only with point-to-point, not in UDP)
	- **Consensus**. System-wide decisions. Not only data but sequence of operations.
---
## Mutual Exclusion
### Definition
- A resource cannot be accessed by several processes at the same time.
- We define a critical section that can only be executed by one process.
### Non-Distributed Systems
- **Mutexes (locks)**.
	- When a process "grabs" it, no other process can do so until the first "drops it".
- **Semaphores** (generalisation of locks)
	- Store a counter that cannot go below 0.
	- Processes can decrement it with `sem_wait()` or increase it with `sem_post()`.
	- If a process tries to decrement it when it is 0, it is locked until other one increments it.
- **Monitors**
	- Data structure in object-oriented programming (java) to mark code as synchronised.
	- Internally works with a lock.
### Distributed Systems
- Types:
	- **Centralized**
		- Some process is designated as the referee
		- Other process ask him for permission through network messages.
	- **Decentralized**
		- There is no referee.
		- Processes agree among themselves which can enter their critical section.
- Algorithm properties
	1. **Mutual exclusion**. Only one process can enter the critical section at a time.
	2. **Survivability (or liveness)** . No process should "starve" (never receive permission)
	3. **Ordering (optional)**. Permissions are granted in the same order they are requested.
### Centralized Referee Solution
- **A referee is designated**
	- We imagine a "token" which the process executing the critical section must have.
	- The referee manages the "token" and it is in charge of granting it.
	- It has a boolean indicating if the token is available and a queue for pending requests.
- **Steps**
	1. A process `P1` request the "token" to the referee.
	2. The referee grants the "token" to `P1` so it enters the critical section.
	3. Another process `P2` requests for the "token".
	4. As the referee has no token, `P2` blocks and it is added to the referee's queue.
	5. The process `P1` ends its critical section and frees the "token".
	6. The referee grants the "token" to the next process in the queue `P2`.
- **Other implementations**
	- Referee can have several tokens for different critical sections.
	- Referee can have a thread per client and implement actual locks.
- **Advantages**
	- Grants mutual exclusion and survivability.
	- Only grants ordering if the queue is a FIFO queue.
- **Problems** (Fault-Tolerance)
	- The referee is a single point of failure.
	- If a token is lost (network or process failure) there is an infinite lockout.
### Token Ring Solution (Descentralized)
- **Ring concept**
	- Administrator configures each node with a unique identifier.
	- Nodes are ordered in a ring where each know the next and previous node's IP.
	- A token is in continuous circulation through the ring from one node to the next.
- **When a process want to access a critical section**
	1. Waits until it receives the token.
	2. It holds the token while executing the critical section.
	3. It retransmits the token when it ends.
- **Advantages**
	- Grants mutual exclusion and survivability.
	- Does not grant ordering. The order is determined by the identifier, not the request time.
- **Problems**
	- Consumes bandwidth continuously. If no critical section, token circulates at high speed.
	- If a message is lost, the token "disappears". Difficult to regenerate based on timeouts.
	- Token stops circulating if a node dies. Ring reconfiguration will imply knowing more nodes.
- **Other descentralized solutions**
	- P2P algorithms based on Distributed Hash Table (DHT)
	- Voting algorithms
---
## Consensus
### Definition
- **Distributed system nodes must make decisions as a whole.**
	- One node makes the decision and remaining nodes must be aware.
	- This ensures consistency across nodes.
- **Node Problems**
	- Nodes may stop working because of `segfault`or hardware errors.
	- Nodes that has been down for a while, loss some information.
	- A node can send wrong or contradictory messages. (byzantine failure)
		- Because of software bug, hardware failure or malicious nodes.
- **Network Problems**
	- Corrupt or out of order data (TCP solves this)
	- Network partitioning (disconnected sub-networks)
		- Some nodes become unreachable.
		- Difficult to differentiate from node down.
### System models
---